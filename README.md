# wordHunt-solver
Find all valid word permutations of a grid of words from the iMessage WordHunt Game and crush your friends.

I got tired of losing WordHunt games to friends on iMessage and was bored so I decided to create a quick 30 minute project to give me a little help.  
Perhaps it can help you too.

## Usage
Run the Python file and start a WordHunt game and enter in the grid of words as fast as you can from left to right starting from the top without any spaces. Generally, you will be the biggest bottleneck while running this program. After running it will print out all the valid word permutations found, with the highest-value/longest words at the bottom where you can swipe for them first.

Speeds depend on your computer and what is concurrently running with the program. For decent optimization I only check words within the lengths of 4 and 10 as realistically I've found from ~20 games that the words you'll be able to swipe for lie within that range, but if it really bothers you you're free to change the constraints.  
**Use wordHunt.py if you don't care about reading the code as it is 1.3-1.4x faster than wordHunt2.py**

## General Notes/Thoughts on Project/Optimization Concerns
- I use a simple DFS algorithm with recursion to find all possible word permutations, and then check which ones among them are actual valid words.
- My first thought was to use an existing Python library to check for valid words because I'm lazy and that's generally one of the benefits of using Python, so I used the popular PyEnchant to check for valid words. However, when testing it was quite slow and I found that PyEnchant's word-check speeds were sluggish. I decided to make my own spellcheck set instead, utilizing Collins Scrabble Words in a text file as my word checker. That sped up the program a crazy amount, I'm guessing PyEnchant's average word-check time complexity is much slower than the O(1) of a set.
- I first wrote the general program as regular functions and then after to tidy up the code for readability/organization I made it into a class and changed a few syntax points. For fun I decided to test the speeds with the regular functions vs the class one expecting the speeds to be identical. To my surprise the regular functions version was consistently faster than the class version, around 1.3-1.4x faster, on which I ran numerous tests on. Though that isn't actually a significant number (especially in this case where the expected run time total for the program should be less than 3 seconds), it still surprised me that there was an actual difference. Through running profilers on tests and a few lookups I found a few interesting tidbits:
  - All else being equal, classes will always end up being slower than regular functions. This has to do with lookup scopes and how variables and attributes differ. A regular local variable is accessed by an index, but an attribute is either a local or a global lookup PLUS an additional lookup by name of the attribute. 
  - Calling a class method is also slower than a regular function because of 1) the slowness of fetching the attribute and 2) because it has an extra function call overhead being a wrapper object of a function you wrote. The differences here are usually negligible however, and the only reason why it was actually apparent in this case is because I access the class attributes and methods hundreds of thousands of times while recurring using DFS. Generally it seems to be agreed upon that the benefit for your code to be tidy and more readable outweighs the negligible speed benefits of just using regular functions. Either way you shouldn't be using Python if speed really matters that much to you. However I added both the regular function and class versions in this repo because why not have both options to either be able to read the code clearly or have that small speed benefit.
  - Loops and lists in Python are slow and inefficient. I found through numerous tests that it was actually more efficient to write 8 different direction-facing functions than to loop through them from a list. Though this part isn't really a big deal, I decided to leave it as 8 different direction-facing functions because I was too lazy to change them and it was still faster in the end. Also the fact that you can speedup loops and general computations that are slow in Python using Cython, numpy or numba ensures that it's actually a non-issue in most cases.
- I'm pretty sure I could optimize certain parts of the code to run even faster, but the program currently runs pretty fast in its current state and beats a majority of other opensource Python implementations I've seen after creating this. This averages 1-2 seconds of runtime for me which I find to be reasonable and much faster than other Python alternatives, and I don't plan to spend much more time on this small project. Currently writing this README has actually taken longer than writing the program itself.
