# wordHunt-solver
Find all valid word permutations of a grid of words from the iMessage WordHunt Game and crush your friends.

I got tired of losing WordHunt games to friends on iMessage and was bored so I decided to create a quick 30 minute project to give me a little help.  
Perhaps it can help you too.

## Usage
Run the Python file and start a WordHunt game and enter in the grid of words as fast as you can from left to right starting from the top row, without entering any spaces. Generally, you will be the biggest bottleneck while running this program. After running it will print out all the valid word permutations found, with the highest-value/longest words at the bottom where you can swipe for them first.

Speeds depend on your computer and what is concurrently running with the program, but generally it should run under a second (due to our best friend data structure trie!).

## General Notes/Thoughts on Project/Optimization Concerns
- I use a trie to store all of the possible words from the Collins word set since the biggest bottleneck outside of the user is the fact that the program will check over redundant/nonexistent permutations of letters otherwise. With a trie we can checkover whether the permutation of letters we currently have can even exist as part of a word, and if it does not we can then return early and simply move on.
- I use a simple DFS algorithm with recursion to find valid word permutations, and then check which ones among them are actual valid words.
- My first thought was to use an existing Python library to check for valid words because I'm lazy and that's generally one of the benefits of using Python, so I used the popular PyEnchant to check for valid words. However, when testing it was quite slow and I found that PyEnchant's word-check speeds were sluggish. I decided to make my own spellcheck set instead, utilizing Collins Scrabble Words in a text file as my word checker. That sped up the program a crazy amount, I'm guessing PyEnchant's average word-check time complexity is non-ideal.
- I first wrote the general program as regular functions and then after to tidy up the code for readability/organization I made it into a class and changed a few syntax points. For fun I decided to test the speeds with the regular functions version versus the class version expecting the speeds to be identical. To my surprise, the regular functions version was consistently faster than the class version, around 1.3-1.4x faster, on which I ran numerous tests on. Though that isn't actually a significant number (especially in this case where the expected run time total for the program should be less than a second), it still surprised me that there was an actual difference. Through running profilers on tests and a few lookups I found a few interesting tidbits:
  - All else being equal, classes will always end up being slower than regular functions. This has to do with lookup scopes and how variables and attributes differ. A regular local variable is accessed by an index, but an attribute is either a local or a global lookup PLUS an additional lookup by name of the attribute. 
  - Calling a class method is also slower than a regular function because of 1) the slowness of fetching the attribute and 2) because it has an extra function call overhead being a wrapper object of a function you wrote. The differences here are usually negligible however, and the only reason why it was actually apparent in this case is because I access the class attributes and methods hundreds of thousands of times while recurring using DFS. Generally it seems to be agreed upon that the benefit for your code to be tidy and more readable outweighs the negligible speed benefits of just using regular functions. Either way you shouldn't be using Python if speed really matters that much to you. However I added both the regular function and class versions in this repo because why not have both options to either be able to read the code clearly or have that small speed benefit.
  - Loops and lists in Python are slow and inefficient. I found through numerous tests that it was actually more efficient to write 8 different direction-facing functions than to loop through them from a list. Though this part isn't really a big deal, I thought it was an interesting tidbit to poke around with. However, the fact that you can speedup loops and general computations that are slow in Python using Cython, numpy or numba ensures that it's actually a non-issue in most cases.
- I'm pretty sure I could optimize certain parts of the code to run even faster, but the program currently runs pretty fast in its current state and beats ~~a majority~~ all other opensource Python implementations I've seen after creating this. This averages less than a second of runtime for me which I find to be reasonable and much faster than other Python alternatives, and I don't plan to spend much more time on this small project. Currently writing this README has actually taken longer than writing the program itself.
